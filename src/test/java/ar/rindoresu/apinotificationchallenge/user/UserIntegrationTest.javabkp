package ar.rindoresu.apinotificationchallenge.user;

import ar.rindoresu.apinotificationchallenge.api.BaseIntegrationTest;
import ar.rindoresu.apinotificationchallenge.pokemon.client.PokemonClient;
import ar.rindoresu.apinotificationchallenge.user.dto.UserRequest;
import org.assertj.core.api.InstanceOfAssertFactories;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InOrder;
import org.mockito.Mockito;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.web.server.LocalServerPort;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.test.context.bean.override.mockito.MockitoSpyBean;
import org.springframework.test.web.reactive.server.WebTestClient;

import java.util.List;

import static org.assertj.core.api.Assertions.assertThat;

class UserIntegrationTest2 extends BaseIntegrationTest {

    private WebTestClient webTestClient;

    @LocalServerPort
    int port;

    @Autowired
    private UserRepository userRepository;

    @MockitoSpyBean
    private PokemonClient pokemonClient;

    @BeforeEach
    void setup() {
        userRepository.deleteAll();
        User u = new User("ash", "pikachu123", "ash@kanto.com", List.of(25, 1));
        userRepository.save(u);

        this.webTestClient = WebTestClient.bindToServer()
                .baseUrl("http://localhost:" + port) // optional, for nicer logs
                .build();
    }


    @Test
    void testCreateUser() {
        // Arrange: mock Pokémon API responses
        Mockito.doReturn("pikachu").when(pokemonClient).getPokemonName(25);
        Mockito.doReturn("bulbasaur").when(pokemonClient).getPokemonName(1);

        UserRequest request = new UserRequest(
                "misty",
                "water123",
                "misty@kanto.com",
                List.of(25, 1)
        );

        // Act + Assert: call the endpoint
        webTestClient.post()
                .uri("/api/users")
                .contentType(MediaType.APPLICATION_JSON)
                .bodyValue(request)
                .exchange()
                .expectStatus().isCreated()
                .expectBody()
                .jsonPath("$.username").isEqualTo("misty")
                .jsonPath("$.email").isEqualTo("misty@kanto.com")
                .jsonPath("$.pokemonNames").value(list -> {
                    assertThat(list)
                            .asInstanceOf(InstanceOfAssertFactories.list(String.class))
                            .containsExactlyInAnyOrder("pikachu", "bulbasaur");
                });

        // Verify the mock was actually used
        InOrder inOrder = Mockito.inOrder(pokemonClient);
        Mockito.verify(pokemonClient, Mockito.times(1)).getPokemonName(25);
        Mockito.verify(pokemonClient, Mockito.times(1)).getPokemonName(1);
        Mockito.verifyNoMoreInteractions(pokemonClient);

        // Verify the user was actually saved in the DB
        List<User> users = userRepository.findAll();
        assertThat(users).hasSize(2); // ash + misty
        assertThat(users)
                .anyMatch(u -> u.getUsername().equals("misty")
                        && u.getEmail().equals("misty@kanto.com"));
    }

    private void assertBadRequest(UserRequest request) {
        webTestClient.post()
                .uri("/api/users")
                .contentType(MediaType.APPLICATION_JSON)
                .bodyValue(request)
                .exchange()
                .expectStatus().isBadRequest()
                .expectBody()
                .jsonPath("$.errors").exists();

        Mockito.verifyNoInteractions(pokemonClient);
    }

    @Test
    void testCreateUser_ValidationError_MissingUsername() {
        UserRequest request = new UserRequest(
                null,
                "test@example.com",
                "pass123",
                List.of(25)
        );

        assertBadRequest(request);
    }

    @Test
    void testCreateUser_ValidationError_MissingPassword() {
        UserRequest request = new UserRequest(
                "misty",
                "misty@pueblopaleta.pa",
                null,
                List.of(25)
        );

        assertBadRequest(request);
    }

    @Test
    void testCreateUser_ValidationError_MissingEmail() {
        UserRequest request = new UserRequest(
                "misty",
                null,
                "water123",
                List.of(25)
        );

        assertBadRequest(request);
    }

    @Test
    void testCreateUser_ValidationError_InvalidEmail() {
        UserRequest request = new UserRequest(
                "misty",
                "not-an-email",
                "water123",
                List.of(25)
        );

        assertBadRequest(request);
    }

    @Test
    void testCreateUser_ValidationError_MissingPokemonList() {
        UserRequest request = new UserRequest(
                "misty",
                "misty@pueblopaleta.pa",
                "water123",
                null
        );

        assertBadRequest(request);
    }

    @Test
    void testCreateUser_ValidationError_InvalidPokemonID() {
        UserRequest request = new UserRequest(
                "misty",
                "misty@pueblopaleta.pa",
                "water123",
                List.of(-45)
        );

        assertBadRequest(request);
    }

    @Test
    void testCreateUser_Conflict_UsernameAlreadyExists() {
        // Arrange: DB already has "ash"
        /* We already do this in the BeforeEach
        User existing = new User("ash", "pikachu123", "ash@kanto.com", List.of(25));
        userRepository.save(existing);
         */

        UserRequest request = new UserRequest(
                "ash", // same username
                "newpass123",
                "newemail@kanto.com",
                List.of(1)
        );

        // Act + Assert
        webTestClient.post()
                .uri("/api/users")
                .contentType(MediaType.APPLICATION_JSON)
                .bodyValue(request)
                .exchange()
                .expectStatus().isEqualTo(HttpStatus.CONFLICT)
                .expectBody()
                .jsonPath("$.message").exists();

        // Pokémon API should NOT be called
        Mockito.verifyNoInteractions(pokemonClient);

        // DB should still contain only the original user
        List<User> users = userRepository.findAll();
        assertThat(users).hasSize(1);
        assertThat(users.get(0).getUsername()).isEqualTo("ash");
    }

    @Test
    void testCreateUser_Conflict_EmailAlreadyExists() {
        // Arrange: DB already has "ash"
        /* We already do this in the BeforeEach
        User existing = new User("ash", "pikachu123", "ash@kanto.com", List.of(25));
        userRepository.save(existing);
         */

        UserRequest request = new UserRequest(
                "misty",
                "water123",
                "ash@kanto.com", // same email
                List.of(1)
        );

        // Act + Assert
        webTestClient.post()
                .uri("/api/users")
                .contentType(MediaType.APPLICATION_JSON)
                .bodyValue(request)
                .exchange()
                .expectStatus().isEqualTo(HttpStatus.CONFLICT)
                .expectBody()
                .jsonPath("$.message").exists();

        // Pokémon API should NOT be called
        Mockito.verifyNoInteractions(pokemonClient);

        // DB should still contain only the original user
        List<User> users = userRepository.findAll();
        assertThat(users).hasSize(1);
        assertThat(users.get(0).getEmail()).isEqualTo("ash@kanto.com");
    }


    @Test
    void testGetUser() {
        Mockito.doReturn("pikachu").when(pokemonClient).getPokemonName(25);
        Mockito.doReturn("bulbasaur").when(pokemonClient).getPokemonName(1);

        webTestClient.get()
                .uri("/api/users/ash")
                .exchange()
                .expectStatus().isOk()
                .expectBody()
                .jsonPath("$.username").isEqualTo("ash")
                .jsonPath("$.pokemonNames").value(list -> {
                    assertThat(list)
                            .asInstanceOf(InstanceOfAssertFactories.list(String.class))
                            .containsExactlyInAnyOrder("pikachu", "bulbasaur");
                });

        // Verify the mock was actually used
        InOrder inOrder = Mockito.inOrder(pokemonClient);
        Mockito.verify(pokemonClient, Mockito.times(1)).getPokemonName(25);
        Mockito.verify(pokemonClient, Mockito.times(1)).getPokemonName(1);
        Mockito.verifyNoMoreInteractions(pokemonClient);

    }
}
